from moviepy import ImageClip, CompositeVideoClip
import random
import numpy as np
from PIL import Image, ImageFilter
import cv2

def apply_gaussian_blur(image_array, blur_radius=5):
    """
    Apply Gaussian blur to image array using OpenCV
    """
    # Convert to uint8 if not already
    if image_array.dtype != np.uint8:
        image_array = image_array.astype(np.uint8)
    
    # Apply Gaussian blur
    blurred = cv2.GaussianBlur(image_array, (blur_radius*2+1, blur_radius*2+1), 0)
    return blurred

def apply_color_filter_to_image(image_array, red_factor=1.0, green_factor=1.0, blue_factor=1.0):
    """
    Apply color filter directly to a numpy image array
    """
    # Make a copy to avoid modifying original
    filtered_image = image_array.copy()
    
    # Apply color multiplication
    filtered_image[:, :, 0] = np.clip(filtered_image[:, :, 0] * red_factor, 0, 255)    # Red
    filtered_image[:, :, 1] = np.clip(filtered_image[:, :, 1] * green_factor, 0, 255)  # Green  
    filtered_image[:, :, 2] = np.clip(filtered_image[:, :, 2] * blue_factor, 0, 255)   # Blue
    
    return filtered_image.astype(np.uint8)

def create_zoomed_blur_slide_clip(image_path, duration, output_path="zoomed_blur_slide.mp4",
                                screen_width=1920, screen_height=1080, 
                                zoom_factor=5.0, blur_radius=8, direction=None,
                                color_filter_type="warm"):
    """
    Create a video clip with zoom, blur, and sliding effects.
    
    Args:
        image_path (str): Path to the input image
        duration (float): Duration of the clip in seconds
        output_path (str): Path for the output video file
        screen_width (int): Width of the output video
        screen_height (int): Height of the output video
        zoom_factor (float): How much to zoom into the image (1.0 = no zoom, 5.0 = 5x zoom)
        blur_radius (int): Radius of Gaussian blur effect
        direction (str): 'left', 'right', 'up', 'down'. If None, chooses randomly
        color_filter_type (str): 'warm', 'cool', 'sepia', or 'none'
    
    Returns:
        VideoClip: The final video clip
    """
    
    # Load and process the image with PIL first
    pil_image = Image.open(image_path)
    
    # Convert to RGB if not already
    if pil_image.mode != 'RGB':
        pil_image = pil_image.convert('RGB')
    
    # Convert to numpy array
    image_array = np.array(pil_image)
    
    # Apply blur effect
    if blur_radius > 0:
        image_array = apply_gaussian_blur(image_array, blur_radius)
    
    # Apply color filter to the image array
    if color_filter_type == "warm":
        image_array = apply_color_filter_to_image(image_array, red_factor=1.3, green_factor=1.1, blue_factor=0.8)
    elif color_filter_type == "cool":
        image_array = apply_color_filter_to_image(image_array, red_factor=0.8, green_factor=1.0, blue_factor=1.3)
    elif color_filter_type == "sepia":
        image_array = apply_color_filter_to_image(image_array, red_factor=1.2, green_factor=1.0, blue_factor=0.7)
    # If color_filter_type == "none", no filter is applied
    
    # Create ImageClip from the processed array
    img_clip = ImageClip(image_array, duration=duration)
    
    # Get image dimensions
    img_height, img_width = image_array.shape[:2]
    
    # Apply zoom by scaling the image up
    zoomed_width = int(img_width * zoom_factor)
    zoomed_height = int(img_height * zoom_factor)
    
    # Resize the image with zoom
    img_clip = img_clip.resized((zoomed_width, zoomed_height))
    
    # Choose direction randomly if not specified
    if direction is None:
        direction = random.choice(['left', 'right', 'up', 'down'])
    
    # Calculate sliding parameters based on direction
    if direction in ['left', 'right']:
        # Horizontal sliding
        if zoomed_width > screen_width:
            max_slide = zoomed_width - screen_width
            
            if direction == 'left':
                start_pos_x = 0
                end_pos_x = -max_slide
            else:  # direction == 'right'
                start_pos_x = -max_slide
                end_pos_x = 0
        else:
            # Image is narrower than screen
            max_slide = screen_width - zoomed_width
            
            if direction == 'left':
                start_pos_x = max_slide
                end_pos_x = 0
            else:  # direction == 'right'
                start_pos_x = 0
                end_pos_x = max_slide
        
        # Center vertically
        start_pos_y = end_pos_y = (screen_height - zoomed_height) // 2
        
    else:  # direction in ['up', 'down']
        # Vertical sliding
        if zoomed_height > screen_height:
            max_slide = zoomed_height - screen_height
            
            if direction == 'up':
                start_pos_y = 0
                end_pos_y = -max_slide
            else:  # direction == 'down'
                start_pos_y = -max_slide
                end_pos_y = 0
        else:
            # Image is shorter than screen
            max_slide = screen_height - zoomed_height
            
            if direction == 'up':
                start_pos_y = max_slide
                end_pos_y = 0
            else:  # direction == 'down'
                start_pos_y = 0
                end_pos_y = max_slide
        
        # Center horizontally
        start_pos_x = end_pos_x = (screen_width - zoomed_width) // 2
    
    # Create the sliding animation function
    def get_position(t):
        progress = t / duration
        current_x = start_pos_x + (end_pos_x - start_pos_x) * progress
        current_y = start_pos_y + (end_pos_y - start_pos_y) * progress
        return (current_x, current_y)
    
    # Apply position animation
    img_clip = img_clip.with_position(get_position)
    
    # Create final composite with black background
    clip = CompositeVideoClip([img_clip], size=(screen_width, screen_height))
    
    return clip

def apply_advanced_color_filter(image_array, filter_type="sepia"):
    """
    Apply advanced color filters using matrix transformations
    """
    filtered_image = image_array.copy().astype(np.float32)
    
    if filter_type == "sepia":
        # Sepia transformation matrix
        sepia_matrix = np.array([
            [0.393, 0.769, 0.189],
            [0.349, 0.686, 0.168],
            [0.272, 0.534, 0.131]
        ])
        # Reshape image for matrix multiplication
        h, w, c = filtered_image.shape
        filtered_image = filtered_image.reshape(-1, 3)
        filtered_image = np.dot(filtered_image, sepia_matrix.T)
        filtered_image = filtered_image.reshape(h, w, 3)
        
    elif filter_type == "vintage":
        # Vintage filter with reduced contrast and warm tint
        filtered_image = filtered_image * 0.8 + 30  # Reduce contrast, add warmth
        filtered_image[:, :, 0] *= 1.1  # Slight red boost
        filtered_image[:, :, 2] *= 0.9  # Slight blue reduction
        
    elif filter_type == "cold":
        # Cold/blue filter
        filtered_image[:, :, 0] *= 0.7  # Reduce red
        filtered_image[:, :, 1] *= 0.9  # Slightly reduce green
        filtered_image[:, :, 2] *= 1.3  # Boost blue
        
    elif filter_type == "dramatic":
        # High contrast dramatic look
        filtered_image = (filtered_image - 128) * 1.5 + 128  # Increase contrast
        filtered_image[:, :, 0] *= 1.1  # Slight red boost
    
    return np.clip(filtered_image, 0, 255).astype(np.uint8)

def create_zoomed_blur_slide_advanced(image_path, duration, output_path="zoomed_blur_slide_advanced.mp4",
                                    screen_width=1920, screen_height=1080,
                                    zoom_factor=5.0, blur_radius=8, direction=None,
                                    filter_type="sepia"):
    """
    Advanced version with matrix-based color filters, zoom, and blur effects
    """
    # Load and process the image
    pil_image = Image.open(image_path)
    if pil_image.mode != 'RGB':
        pil_image = pil_image.convert('RGB')
    
    image_array = np.array(pil_image)
    
    # Apply blur effect first
    if blur_radius > 0:
        image_array = apply_gaussian_blur(image_array, blur_radius)
    
    # Apply advanced color filter
    if filter_type != "none":
        image_array = apply_advanced_color_filter(image_array, filter_type)
    
    # Create ImageClip from the processed array
    img_clip = ImageClip(image_array, duration=duration)
    
    # Get image dimensions and apply zoom
    img_height, img_width = image_array.shape[:2]
    zoomed_width = int(img_width * zoom_factor)
    zoomed_height = int(img_height * zoom_factor)
    
    img_clip = img_clip.resized((zoomed_width, zoomed_height))
    
    # Choose direction randomly if not specified
    if direction is None:
        direction = random.choice(['left', 'right', 'up', 'down'])
    
    # Calculate sliding parameters (same logic as basic version)
    if direction in ['left', 'right']:
        if zoomed_width > screen_width:
            max_slide = zoomed_width - screen_width
            if direction == 'left':
                start_pos_x, end_pos_x = 0, -max_slide
            else:
                start_pos_x, end_pos_x = -max_slide, 0
        else:
            max_slide = screen_width - zoomed_width
            if direction == 'left':
                start_pos_x, end_pos_x = max_slide, 0
            else:
                start_pos_x, end_pos_x = 0, max_slide
        
        start_pos_y = end_pos_y = (screen_height - zoomed_height) // 2
    else:
        if zoomed_height > screen_height:
            max_slide = zoomed_height - screen_height
            if direction == 'up':
                start_pos_y, end_pos_y = 0, -max_slide
            else:
                start_pos_y, end_pos_y = -max_slide, 0
        else:
            max_slide = screen_height - zoomed_height
            if direction == 'up':
                start_pos_y, end_pos_y = max_slide, 0
            else:
                start_pos_y, end_pos_y = 0, max_slide
        
        start_pos_x = end_pos_x = (screen_width - zoomed_width) // 2
    
    def get_position(t):
        progress = t / duration
        current_x = start_pos_x + (end_pos_x - start_pos_x) * progress
        current_y = start_pos_y + (end_pos_y - start_pos_y) * progress
        return (current_x, current_y)
    
    img_clip = img_clip.with_position(get_position)
    clip = CompositeVideoClip([img_clip], size=(screen_width, screen_height))
    
    clip.write_videofile(output_path, fps=24, codec='libx264')
    return clip

# Example usage
if __name__ == "__main__":
    image_path = "CD/cte2.jpg"
    duration = 6
    output_path = "zoomed_blur_slide1.mp4"
    
    # Basic version with simple color filters
    '''
    clip = create_zoomed_blur_slide_clip(
        image_path=image_path,
        duration=duration,
        output_path=output_path,
        screen_width=1920,
        screen_height=1080,
        zoom_factor=4.0,  # 4x zoom
        blur_radius=10,   # Strong blur effect
        direction='right',  # or 'left', 'up', 'down', None for random
        color_filter_type="warm"  # "warm", "cool", "sepia", or "none"
    )
    clip.write_videofile(output_path, fps=24, codec='libx264')
    '''
    # Or use the advanced version with matrix-based filters
    clip = create_zoomed_blur_slide_advanced(
        image_path=image_path,
        duration=duration,
        output_path="advanced_zoomed_blur_slide.mp4",
        zoom_factor=8.0,
        blur_radius=16,
        direction='up',
        filter_type="sepia"  # "sepia", "vintage", "cold", "dramatic", or "none"
    )
    
    print(f"Zoomed blur slide clip created: {output_path}")
    print(f"Duration: {duration} seconds")
    print(f"Zoom factor: 4.0x with blur and sliding effect")
